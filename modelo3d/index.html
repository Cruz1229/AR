<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <title>AR.js con Three.js - Ejemplo Básico</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="info">
        Apunta la cámara hacia el marcador Hiro
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- AR.js para Three.js -->
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/three.js/build/ar-threex.js"></script>

    <script>
        let scene, camera, renderer;
        let arToolkitSource, arToolkitContext;
        let markerRoot;
        let cube, text3D;
        let isMarkerVisible = false;

        init();
        animate();

        function init() {
            // Crear la escena
            scene = new THREE.Scene();

            // Crear la cámara
            camera = new THREE.Camera();
            scene.add(camera);

            // Crear el renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Configurar AR Toolkit Source (webcam)
            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam',
            });

            arToolkitSource.init(() => {
                onResize();
            });

            // Manejar redimensionamiento
            window.addEventListener('resize', onResize);

            // Configurar AR Toolkit Context
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/three.js/data/camera_para.dat',
                detectionMode: 'mono',
            });

            arToolkitContext.init(() => {
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
            });

            // Crear el grupo para el marcador
            markerRoot = new THREE.Group();
            scene.add(markerRoot);

            // Configurar el marcador Hiro
            let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                type: 'pattern',
                patternUrl: 'https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/three.js/data/patt.hiro',
            });

            // Eventos del marcador
            markerControls.addEventListener('markerFound', () => {
                isMarkerVisible = true;
                document.getElementById('info').innerHTML = '¡Marcador detectado!';
            });

            markerControls.addEventListener('markerLost', () => {
                isMarkerVisible = false;
                document.getElementById('info').innerHTML = 'Apunta la cámara hacia el marcador Hiro';
            });

            // Configurar iluminación
            setupLighting();

            // Crear contenido AR
            createARContent();
        }

        function setupLighting() {
            // Luz ambiental
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // Luz direccional
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
        }

        function createARContent() {
            // Crear un cubo colorido
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0xff0000 }), // Rojo
                new THREE.MeshLambertMaterial({ color: 0x00ff00 }), // Verde
                new THREE.MeshLambertMaterial({ color: 0x0000ff }), // Azul
                new THREE.MeshLambertMaterial({ color: 0xffff00 }), // Amarillo
                new THREE.MeshLambertMaterial({ color: 0xff00ff }), // Magenta
                new THREE.MeshLambertMaterial({ color: 0x00ffff })  // Cian
            ];
            
            cube = new THREE.Mesh(geometry, materials);
            cube.position.set(0, 0.5, 0);
            cube.castShadow = true;
            markerRoot.add(cube);

            // Crear una esfera que orbita
            const sphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const sphereMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(2, 1, 0);
            sphere.castShadow = true;
            markerRoot.add(sphere);

            // Crear un plano base
            const planeGeometry = new THREE.PlaneGeometry(4, 4);
            const planeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x888888, 
                transparent: true, 
                opacity: 0.5 
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            markerRoot.add(plane);

            // Crear texto 3D simple usando geometría
            createText3D();
        }

        function createText3D() {
            // Crear texto usando geometría de texto simple
            const loader = new THREE.FontLoader();
            
            // Como no podemos cargar fuentes externas fácilmente, usaremos formas simples
            // para crear un mensaje visual
            
            // Crear varias pequeñas esferas para formar "HOLA"
            const letterMaterial = new THREE.MeshLambertMaterial({ color: 0xff6600 });
            const letterGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // Posiciones aproximadas para "HOLA"
            const positions = [
                // H
                [-2, 2, 0], [-2, 1.5, 0], [-2, 1, 0], [-1.5, 1.5, 0], [-1, 2, 0], [-1, 1.5, 0], [-1, 1, 0],
                // O
                [-0.5, 2, 0], [-0.5, 1, 0], [0, 2, 0], [0, 1, 0], [0.5, 1.5, 0],
                // L
                [1, 2, 0], [1, 1.5, 0], [1, 1, 0], [1.5, 1, 0],
                // A
                [2, 1, 0], [2, 1.5, 0], [2, 2, 0], [2.5, 1.5, 0], [3, 1, 0], [3, 1.5, 0], [3, 2, 0]
            ];

            positions.forEach(pos => {
                const letter = new THREE.Mesh(letterGeometry, letterMaterial);
                letter.position.set(pos[0], pos[1], pos[2]);
                markerRoot.add(letter);
            });
        }

        function onResize() {
            arToolkitSource.onResize();
            arToolkitSource.copySizeTo(renderer.domElement);
            if (arToolkitContext.arController !== null) {
                arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Actualizar AR
            if (arToolkitSource && arToolkitSource.ready) {
                arToolkitContext.update(arToolkitSource.domElement);
            }

            // Animar el cubo cuando el marcador esté visible
            if (isMarkerVisible && cube) {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.02;
            }

            // Renderizar la escena
            renderer.render(scene, camera);
        }

        // Manejar errores de cámara
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                console.log('Cámara inicializada correctamente');
            })
            .catch(err => {
                console.error('Error al acceder a la cámara:', err);
                document.getElementById('info').innerHTML = 'Error: No se pudo acceder a la cámara';
            });
    </script>
</body>
</html>